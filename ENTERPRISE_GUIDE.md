# QR File Transfer - Enterprise Implementation Guide

> Complete enterprise-level system for secure, air-gapped file transfers via QR codes

## üìã Executive Summary

This document provides a comprehensive guide for implementing an enterprise-grade QR code file transfer system consisting of two applications:

1. **QR Generator** (Python) - Encodes files into QR code sequences
2. **QR Scanner** (PWA) - Scans and reconstructs files from QR codes

### Business Value

- **Security**: Air-gapped transfer with no network dependencies
- **Compliance**: Zero data persistence options for regulated environments
- **Reliability**: Error correction and integrity verification
- **Scalability**: Support for files up to 100MB+
- **Accessibility**: Works on all platforms without special hardware

### Target Use Cases

- Government/military secure data transfer
- Healthcare data exchange (HIPAA compliance)
- Financial transactions (air-gapped security)
- Industrial control systems (OT/IT separation)
- Disaster recovery scenarios (network-independent)

---

## ‚ö†Ô∏è CRITICAL: Generator/Scanner Compatibility

**THE SCANNER MUST ALWAYS BE ABLE TO SCAN AND RECONSTRUCT QR CODES GENERATED BY THE GENERATOR.**

This is the FUNDAMENTAL operational requirement. The entire system fails if scanner cannot decode generator output.

### Why Compatibility is Mission-Critical

In an air-gapped deployment:
- **No network**: Generator and scanner are on physically separate devices
- **No mediation**: No server to convert between formats or negotiate versions
- **No updates**: Cannot push patches to deployed systems in the field
- **No fallback**: If scanner can't decode QR codes ‚Üí mission failure

**Compatibility is not negotiable. It is a HARD CONSTRAINT.**

### Operational Compatibility Requirements

#### Before Deployment - MANDATORY TESTING

**End-to-End Compatibility Test:**
```bash
# 1. Generate test QR codes on generator device
cd generator/
python qr_generator.py test-file.pdf
python qr_generator.py --encrypt test-document.docx

# 2. Transfer scanner to separate device (USB/CD)
# Simulate air-gap: NO network connection between devices

# 3. Scan ALL QR codes with scanner
# On scanner device: Open browser, load scanner, scan each file

# 4. Verify byte-for-byte reconstruction
sha256sum test-file.pdf
# On scanner device:
sha256sum downloaded-test-file.pdf
# MUST MATCH EXACTLY!

# 5. Repeat for different file types
# Test matrix:
# - Compression: zstd level 22 (ONLY algorithm supported)
# - Encryption: none, aes256gcm
# - File types: .txt, .pdf, .docx, .jpg, .png, .zip, .mp4
# - File sizes: 1KB, 100KB, 1MB, 10MB, 50MB
# ALL must reconstruct perfectly!
```

**If ANY test fails ‚Üí DO NOT DEPLOY. System is broken.**

#### Deployment Verification Checklist

Before deploying to production:

- [ ] **Protocol V3 compatibility verified** - Binary format matches exactly
- [ ] **Zstd-22 decompression works** - ONLY compression algorithm, must succeed
- [ ] **AES-256-GCM encryption works** - ONLY encryption algorithm (if used)
- [ ] **Large file tested** - 10MB+ file reconstructs correctly
- [ ] **Multi-platform tested** - Generator (Python) + Scanner (iOS, Android, Desktop)
- [ ] **Out-of-order scanning tested** - Scan QRs in random order, still reconstructs
- [ ] **Hash validation passes** - SHA-256 checksum matches original
- [ ] **Metadata extraction works** - Filename, size, compression=zstd, encryption=aes256gcm
- [ ] **Air-gap verified** - ZERO network communication during transfer
- [ ] **fzstd library bundled** - Zstd decompression library present in scanner

**IF ANY CHECKLIST ITEM FAILS ‚Üí HALT DEPLOYMENT.**

#### What Breaks Compatibility (Critical Errors)

These changes WILL break generator/scanner compatibility:

‚ùå **Generator changes binary encoding WITHOUT updating scanner**
- Example: Generator adds field at byte offset 20, scanner still expects data at 20

‚ùå **Scanner removes Zstd decompression support**
- Example: Scanner breaks Zstd library, but generator ONLY uses Zstd-22

‚ùå **Generator changes chunk size WITHOUT updating scanner**
- Example: Generator uses 3000-byte chunks, scanner expects max 2272

‚ùå **Scanner changes completion detection logic**
- Example: Scanner requires sequential scanning, but generator assumes any order

‚ùå **Generator changes metadata fields WITHOUT updating scanner**
- Example: Generator renames "compression" to "comp_algo", scanner looks for "compression"

‚ùå **Protocol version mismatch**
- Example: Generator uses Protocol V3.1, scanner only supports V3.0

#### Compatibility Maintenance Procedures

**When updating generator:**
1. Review Protocol V3 specification (Section below)
2. If binary format changes ‚Üí update scanner parser in lockstep
3. If new compression algorithm added ‚Üí add to scanner decompression service
4. If metadata fields change ‚Üí update scanner metadata parser
5. Run full compatibility test suite (all compression types, file types, sizes)
6. Deploy generator and scanner TOGETHER (not separately)

**When updating scanner:**
1. Review generator Protocol V3 encoder (generator/IMPLEMENTATION.md)
2. Verify binary parser byte offsets match generator exactly
3. Verify all compression algorithms still supported
4. Verify chunk assembly logic handles out-of-order scanning
5. Run full compatibility test suite
6. Deploy generator and scanner TOGETHER

**Version Control:**
- Generator version tag: `v3.0-generator`
- Scanner version tag: `v3.0-scanner`
- BOTH must have matching major.minor version (3.0)

**Breaking change protocol:**
1. If Protocol V4 needed ‚Üí create NEW generator AND scanner
2. Mark Protocol V3 as "stable - do not modify"
3. Test V4 generator + V4 scanner compatibility
4. Deploy V4 as separate system (not update to V3)

### Compatibility Troubleshooting

**Problem**: Scanner shows "Unsupported protocol version"
**Cause**: Generator using different protocol than scanner
**Fix**: Verify both are Protocol V3 exactly

**Problem**: Scanner shows "Decompression failed"
**Cause**: Scanner missing compression algorithm library
**Fix**: Verify fzstd library bundled (for Zstd), test decompression manually

**Problem**: Scanner shows "Hash mismatch"
**Cause**: Data corruption during scanning OR incompatible binary format
**Fix**: Verify binary parser byte offsets match generator encoder

**Problem**: Scanner never shows "Complete" status
**Cause**: Completion detection logic broken OR `total` field not parsed
**Fix**: Verify scanner extracts `total` from binary QRs (bytes 20-23)

**Problem**: Downloaded file is corrupted
**Cause**: Chunk assembly order wrong OR missing chunks not detected
**Fix**: Verify scanner assembles chunks in index order (0, 1, 2, ..., total-1)

---

## üèóÔ∏è System Architecture

### High-Level System View

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   QR GENERATOR      ‚îÇ                    ‚îÇ    QR SCANNER       ‚îÇ
‚îÇ   (Python App)      ‚îÇ                    ‚îÇ    (PWA - Web)      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                     ‚îÇ                    ‚îÇ                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ                    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ File Input   ‚îÇ   ‚îÇ                    ‚îÇ  ‚îÇ Camera       ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ                    ‚îÇ  ‚îÇ Scanner      ‚îÇ   ‚îÇ
‚îÇ         ‚îÇ           ‚îÇ                    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ                    ‚îÇ         ‚îÇ           ‚îÇ
‚îÇ  ‚îÇ Compression  ‚îÇ   ‚îÇ                    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ Encryption   ‚îÇ   ‚îÇ                    ‚îÇ  ‚îÇ QR Detection ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ                    ‚îÇ  ‚îÇ & Parsing    ‚îÇ   ‚îÇ
‚îÇ         ‚îÇ           ‚îÇ                    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ                    ‚îÇ         ‚îÇ           ‚îÇ
‚îÇ  ‚îÇ Chunking     ‚îÇ   ‚îÇ                    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ                    ‚îÇ  ‚îÇ Chunk        ‚îÇ   ‚îÇ
‚îÇ         ‚îÇ           ‚îÇ                    ‚îÇ  ‚îÇ Assembly     ‚îÇ   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ  ‚îÇ QR Code      ‚îÇ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂  AIR   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ           ‚îÇ
‚îÇ  ‚îÇ Generation   ‚îÇ   ‚îÇ     ‚îÇ  GAP   ‚îÇ    ‚îÇ         ‚îÇ           ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ         ‚îÇ           ‚îÇ                    ‚îÇ  ‚îÇ Decompression‚îÇ   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ                    ‚îÇ  ‚îÇ Decryption   ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ Display      ‚îÇ   ‚îÇ                    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ  ‚îÇ (GUI/CLI)    ‚îÇ   ‚îÇ                    ‚îÇ         ‚îÇ           ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ                    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ                     ‚îÇ                    ‚îÇ  ‚îÇ File Output  ‚îÇ   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
                                          ‚îÇ                     ‚îÇ
                                          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Data Flow

1. **Generation Phase** (Generator)
   - File ‚Üí Validation ‚Üí Compression ‚Üí Encryption ‚Üí Chunking ‚Üí Error Correction ‚Üí QR Encoding ‚Üí Display

2. **Transfer Phase** (Air Gap)
   - QR codes displayed on one screen
   - Camera scans from another device
   - No network, no physical connection

3. **Reception Phase** (Scanner)
   - Camera ‚Üí QR Detection ‚Üí Protocol Parsing ‚Üí Chunk Assembly ‚Üí Decompression ‚Üí Decryption ‚Üí File Output

---

## üì° Protocol V3 Specification

### ‚ö†Ô∏è OPTIMIZED FOR MINIMAL QR CODES

**This system uses ONLY Protocol V3.** No backward compatibility with v1 or v2.

**OPTIMIZATION STRATEGY:**
- ‚úÖ **Metadata once** (first QR only) - NOT repeated
- ‚úÖ **Binary data chunks** (base64 only for first QR) - saves 33% space
- ‚úÖ **Maximum compression** (Zstd level 22 ONLY - best compression ratio)
- ‚úÖ **Optimal chunk size** (2272 bytes for QR-40M with binary format)
- ‚úÖ **Error correction balance** (Medium for best capacity/reliability)
- ‚úÖ **Single algorithm** (Zstd-22 only - simplicity for air-gap reliability)

**Result**: 50-70% fewer QR codes compared to naive implementation.

---

### Protocol Formats

#### Format A: Header QR (First QR Only - idx=0)

JSON with complete metadata:

```json
{
  "v": "3.0",
  "sid": "uuid-v4-session-id",
  "idx": 0,
  "total": 100,
  "data": "base64_encoded_chunk_data",
  "hash": "sha256_chunk_hash",
  "meta": {
    "filename": "example.txt",
    "size": 1048576,
    "compression": "zstd",
    "compression_level": 22,
    "encryption": "aes256gcm",
    "checksum": "sha256_file_hash",
    "timestamp": "2025-11-13T12:00:00Z",
    "mime_type": "text/plain",
    "chunk_size": 2953,
    "qr_version": "40-M"
  },
  "ec": {
    "type": "reed-solomon",
    "data": "base64_encoded_ec_data"
  }
}
```

#### Format B: Data QR (Subsequent QRs - idx‚â•1)

**OPTIMIZED**: Binary format, no JSON overhead

```
[sid:16bytes][idx:4bytes][total:4bytes][data:variable][hash:32bytes]
```

**Structure:**
- Bytes 0-15: Session ID (UUID binary, 16 bytes)
- Bytes 16-19: Chunk index (uint32 big-endian, 4 bytes)
- **Bytes 20-23: Total chunks (uint32 big-endian, 4 bytes)** ‚≠ê CRITICAL for air-gap!
- Bytes 24-N: Raw binary chunk data (NOT base64)
- Bytes N+1 to end: SHA-256 hash (32 bytes)

**QR Encoding**: Binary mode (NOT alphanumeric or text)

**Why include `total` in EVERY QR?**
- ‚úÖ **Air-gap robustness**: Scanner can determine completion from ANY QR
- ‚úÖ **Out-of-order scanning**: QRs can be scanned in any sequence
- ‚úÖ **Missing header resilience**: Even if idx=0 is damaged, scanner knows total
- ‚úÖ **Progress tracking**: Scanner shows "45/100 chunks" immediately
- Cost: Only 4 bytes per chunk (~0.2% overhead for 1381 chunks)

**Why binary?**
- JSON + base64 for 2KB data = ~3.4KB QR code
- Binary format for 2KB data = ~2.09KB QR code
- **38% reduction in data size!**

### Field Specifications

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `v` | string | ‚úÖ | Protocol version "3.0" |
| `sid` | string | ‚úÖ | UUID v4 session identifier |
| `idx` | number | ‚úÖ | Zero-based chunk index |
| `total` | number | ‚úÖ | Total number of chunks |
| `data` | string | ‚úÖ | Base64-encoded chunk data |
| `hash` | string | ‚úÖ | SHA-256 hash of chunk data |
| `meta` | object | ‚úÖ | File metadata (see below) |
| `ec` | object | ‚ùå | Error correction data (optional) |

### Metadata Fields

| Field | Type | Required | Valid Values |
|-------|------|----------|--------------|
| `filename` | string | ‚úÖ | Original filename |
| `size` | number | ‚úÖ | Total file size in bytes |
| `compression` | string | ‚úÖ | `zstd` (ONLY - level 22 always) |
| `compression_level` | number | ‚úÖ | Always 22 (maximum compression) |
| `encryption` | string | ‚úÖ | `aes256gcm` or `none` (ONLY options) |
| `checksum` | string | ‚úÖ | SHA-256 hash of complete file |
| `timestamp` | string | ‚úÖ | ISO 8601 UTC timestamp |
| `mime_type` | string | ‚úÖ | MIME type of file |
| `chunk_size` | number | ‚úÖ | Bytes per chunk (optimized) |
| `qr_version` | string | ‚úÖ | QR version used (e.g., "40-M") |

### Supported Algorithms (SIMPLIFIED FOR RELIABILITY)

**Compression (SINGLE ALGORITHM - BEST FOR MINIMAL QR CODES):**
- `zstd`: **Zstandard level 22** (ONLY compression algorithm supported)
  - Compression ratio: 25-35% (BEST available)
  - Speed: Medium (hardware acceleration available on modern CPUs)
  - Result: Minimum number of QR codes
  - **Why ONLY Zstd-22?**
    - ‚úÖ Best compression ratio = fewest QR codes
    - ‚úÖ Simpler system = more reliable for air-gap
    - ‚úÖ Single code path = easier to verify compatibility
    - ‚úÖ Fewer failure points in military deployment

**Encryption (SINGLE ALGORITHM - BEST FOR FAST TRANSFER):**
- `aes256gcm`: **AES-256-GCM with PBKDF2** (ONLY encryption algorithm supported)
  - Hardware accelerated (AES-NI on modern CPUs)
  - Authenticated encryption (integrity + confidentiality)
  - 100,000 PBKDF2 iterations for key derivation
  - **Why ONLY AES-256-GCM?**
    - ‚úÖ Hardware acceleration = fastest encryption/decryption
    - ‚úÖ Authenticated = detects tampering automatically
    - ‚úÖ Widely supported = works on all modern devices
    - ‚úÖ Battle-tested = military-grade, NIST approved
- `none`: No encryption (optional - for non-sensitive files)

**Hash:**
- SHA-256 for all checksums and hashes

**Error Correction (Optional):**
- Reed-Solomon erasure coding

---

### QR Code Capacity Optimization

**CRITICAL**: Use maximum QR version and optimal error correction for minimum QR codes.

#### QR Code Capacity Table (Binary Mode)

| QR Version | Error Correction | Max Bytes | Recommended Chunk Size |
|------------|------------------|-----------|------------------------|
| 40-L (Low) | ~7% errors | **2953** | 2900 bytes ‚ö†Ô∏è Risky |
| 40-M (Med) | ~15% errors | **2331** | 2280 bytes ‚úÖ **RECOMMENDED** |
| 40-Q (Quar) | ~25% errors | **1663** | 1610 bytes |
| 40-H (High) | ~30% errors | **1273** | 1220 bytes ‚ö†Ô∏è Too conservative |

**Recommendation**: Use **40-M (Medium)** - best balance of capacity and reliability.

#### Optimal Chunk Size Formula

```python
# For Format B (Binary Data QRs - idx >= 1)
OVERHEAD = 16 (sid) + 4 (idx) + 4 (total) + 32 (hash) = 56 bytes

# QR-40M capacity
QR_40M_CAPACITY = 2331 bytes

# Optimal chunk size
CHUNK_SIZE = QR_40M_CAPACITY - OVERHEAD = 2275 bytes  # Exact fit for air-gap protocol

# Recommended (round down slightly for encoding safety margin)
RECOMMENDED_CHUNK_SIZE = 2272 bytes  # Safe margin for binary encoding
```

#### Number of QR Codes Calculation

```python
# Example: 10MB file with Zstd-22 compression

original_size = 10 * 1024 * 1024  # 10MB = 10,485,760 bytes
compression_ratio = 0.30  # Zstd-22 achieves ~30% of original
compressed_size = original_size * compression_ratio  # 3,145,728 bytes

# Header QR (idx=0): JSON format, ~800 bytes, 1 QR
header_qrs = 1

# Data QRs (idx>=1): Binary format
data_to_split = compressed_size
chunk_size = 2280 bytes
data_qrs = ceil(data_to_split / chunk_size)  # 1380 QRs

total_qrs = header_qrs + data_qrs  # 1381 QRs

# Compare to NAIVE approach (JSON + base64 everywhere):
# chunk_size_naive = 1000 bytes (base64 overhead)
# naive_qrs = ceil(compressed_size / 1000)  # 3146 QRs
#
# SAVINGS: 56% fewer QR codes! (1381 vs 3146)
```

#### Compression Impact on QR Count

| File Type | Size | No Compression | Zstd-3 | Zstd-22 | Savings |
|-----------|------|----------------|--------|---------|---------|
| Text (.txt) | 1MB | 463 QRs | 116 QRs | **81 QRs** | 82% fewer! |
| Code (.py) | 500KB | 232 QRs | 58 QRs | **41 QRs** | 82% fewer! |
| JSON (.json) | 2MB | 926 QRs | 185 QRs | **130 QRs** | 86% fewer! |
| Binary (.bin) | 1MB | 463 QRs | 417 QRs | **405 QRs** | 12% fewer |
| Image (.jpg) | 1MB | 463 QRs | 463 QRs | **463 QRs** | 0% (skip compression!) |

**Key Insight**: Compressible files (text, code, JSON) benefit enormously from Zstd-22!

### Compatibility Requirements

**Generator MUST:**
1. Always set `v` to "3.0"
2. Generate UUID v4 for `sid`
3. Base64-encode all binary data
4. Calculate SHA-256 hashes correctly
5. Include all required metadata fields
6. Use ISO 8601 format for timestamps

**Scanner MUST:**
1. Reject any version other than "3.0"
2. Validate all required fields present
3. Verify chunk hashes match data
4. Support all compression algorithms
5. Support AES-256-GCM encryption
6. Parse metadata correctly

### Example Implementation

See:
- Generator: `generator/IMPLEMENTATION.md` Section 3
- Scanner: `scanner/IMPLEMENTATION.md` Section 2.1

---

## üéØ Implementation Strategy

### Phase 1: Foundation (Weeks 1-2)

#### Generator Implementation

```bash
generator/
‚îú‚îÄ‚îÄ Set up project structure
‚îú‚îÄ‚îÄ Implement core domain models
‚îú‚îÄ‚îÄ Create file processing pipeline
‚îú‚îÄ‚îÄ Implement compression service
‚îú‚îÄ‚îÄ Implement encryption service
‚îú‚îÄ‚îÄ Create QR generation service
‚îî‚îÄ‚îÄ Build CLI interface
```

**Deliverables:**
- Working CLI generator
- Unit tests for core services
- Basic documentation

#### Scanner Implementation

```bash
scanner/
‚îú‚îÄ‚îÄ Set up PWA structure
‚îú‚îÄ‚îÄ Implement camera service
‚îú‚îÄ‚îÄ Create QR scanning engine
‚îú‚îÄ‚îÄ Implement chunk assembly
‚îú‚îÄ‚îÄ Create storage service
‚îî‚îÄ‚îÄ Build basic UI
```

**Deliverables:**
- Working PWA scanner
- Camera access on all platforms
- Basic chunk assembly

### Phase 2: Features (Weeks 3-4)

#### Generator Features

- [ ] GUI interface (Tkinter)
- [ ] REST API interface
- [ ] Protocol v3 implementation
- [ ] Reed-Solomon error correction
- [ ] Session management
- [ ] Performance monitoring

#### Scanner Features

- [ ] Protocol v3 support
- [ ] File preview system
- [ ] Error correction decoding
- [ ] Theme management
- [ ] IndexedDB persistence
- [ ] Download management

### Phase 3: Enterprise Features (Weeks 5-6)

#### Advanced Capabilities

- [ ] Automated testing (E2E)
- [ ] Performance benchmarking
- [ ] Security audit
- [ ] Documentation completion
- [ ] Docker deployment
- [ ] CI/CD pipeline

#### Quality Assurance

- [ ] Cross-platform testing
- [ ] Load testing
- [ ] Security penetration testing
- [ ] User acceptance testing
- [ ] Production hardening

### Phase 4: Production (Week 7+)

- [ ] Production deployment
- [ ] Monitoring setup
- [ ] Incident response plan
- [ ] User training materials
- [ ] Support documentation
- [ ] Maintenance plan

---

## üíª Development Workflows

### Generator Development

```bash
# Setup
cd generator/
python -m venv venv
source venv/bin/activate  # or `venv\Scripts\activate` on Windows
pip install -r requirements.txt
pip install -r requirements-dev.txt

# Development
# 1. Write tests first (TDD)
pytest tests/unit/test_new_feature.py

# 2. Implement feature
# Edit src/core/services/new_service.py

# 3. Run tests
pytest

# 4. Check code quality
ruff check src/
black src/
mypy src/

# 5. Commit changes
git add .
git commit -m "feat: add new feature"
```

### Scanner Development

```bash
# Setup
cd scanner/
npm install

# Development
# 1. Start dev server
npm run dev

# 2. Open in browser
# https://localhost:3000

# 3. Make changes
# Edit public/js/...

# 4. Hot reload automatic

# 5. Test
npm test

# 6. Lint
npm run lint

# 7. Commit
git add .
git commit -m "feat: add new feature"
```

---

## üîÑ Integration Testing

### End-to-End Workflow Test

```bash
# Terminal 1: Start Generator
cd generator/
python -m src.main generate test_file.txt --compression zstd --fps 2.0

# Terminal 2: Start Scanner
cd scanner/
npm run dev

# Browser: Open https://localhost:3000
# 1. Click "Start Scanning"
# 2. Point camera at QR codes
# 3. Verify file downloads correctly
# 4. Compare checksums
```

### Automated E2E Test

```python
# tests/e2e/test_full_transfer.py
import pytest
from playwright.sync_api import sync_playwright

def test_full_file_transfer():
    """Test complete file transfer workflow"""

    with sync_playwright() as p:
        # Start generator (Python)
        generator = subprocess.Popen([
            'python', '-m', 'src.main', 'generate',
            'test_data/sample.txt', '--fps', '10'
        ])

        # Start scanner (Browser)
        browser = p.chromium.launch()
        page = browser.new_page()

        # Grant camera permissions
        context = browser.new_context(permissions=['camera'])
        page = context.new_page()

        # Navigate to scanner
        page.goto('https://localhost:3000')

        # Start scanning
        page.click('#start-btn')

        # Wait for completion
        page.wait_for_selector('#download-btn')

        # Verify download
        download = page.wait_for_download()
        assert download.suggested_filename == 'sample.txt'

        # Cleanup
        generator.terminate()
        browser.close()
```

---

## üìä Performance Benchmarks

### Target Performance Metrics

| Metric                    | Target      | Measured    | Status |
|---------------------------|-------------|-------------|--------|
| Generator Startup Time    | <2s         | -           | ‚è≥     |
| QR Generation Rate        | >10 QR/s    | -           | ‚è≥     |
| Scanner Startup Time      | <1s         | -           | ‚è≥     |
| QR Detection Rate         | 5-30 FPS    | -           | ‚è≥     |
| Memory Usage (Generator)  | <500MB      | -           | ‚è≥     |
| Memory Usage (Scanner)    | <250MB      | -           | ‚è≥     |
| CPU Usage (Generator)     | <50%        | -           | ‚è≥     |
| CPU Usage (Scanner)       | <30%        | -           | ‚è≥     |

### Benchmark Tests

```bash
# Generator Benchmarks
cd generator/
pytest tests/performance/test_benchmarks.py --benchmark-only

# Scanner Benchmarks
cd scanner/
npm run test:performance
```

---

## üîí Security Implementation

### Security Checklist

#### Generator

- [ ] Input validation (file size, format)
- [ ] Encryption enabled by default
- [ ] Secure password storage (never in plaintext)
- [ ] Memory cleanup after processing
- [ ] No logging of sensitive data
- [ ] Code signing for executables

#### Scanner

- [ ] Content Security Policy headers
- [ ] HTTPS enforcement
- [ ] Camera permission management
- [ ] Input sanitization (QR data)
- [ ] Secure IndexedDB access
- [ ] No external API calls
- [ ] Memory cleanup after assembly

### Security Testing

```bash
# Static Analysis
cd generator/
bandit -r src/

cd scanner/
npm audit

# Penetration Testing
# Use OWASP ZAP or similar tools
# Test for:
# - XSS vulnerabilities
# - Injection attacks
# - CSRF attacks
# - Data exposure
```

---

## üöÄ Deployment Guide

### Generator Deployment

#### Option 1: PyInstaller Executable

```bash
# Build standalone executable
cd generator/
pyinstaller --onefile --windowed \
    --name "QR Generator" \
    --icon icon.ico \
    src/main.py

# Distribute dist/QR Generator.exe
```

#### Option 2: Docker API

```bash
# Build Docker image
cd generator/
docker build -t qr-generator:3.0.0 .

# Run API server
docker run -d \
    -p 8000:8000 \
    -v /data:/data \
    qr-generator:3.0.0

# Access API at http://localhost:8000
```

#### Option 3: System Package

```bash
# Create Python package
cd generator/
python setup.py sdist bdist_wheel

# Install system-wide
pip install dist/qr_generator-3.0.0-py3-none-any.whl

# Run from anywhere
qr-generate /path/to/file.txt
```

### Scanner Deployment

#### Option 1: Static Hosting (Recommended)

```bash
# Build production bundle
cd scanner/
npm run build

# Deploy dist/ to:
# - GitHub Pages
# - Netlify
# - Vercel
# - AWS S3 + CloudFront
# - Any CDN

# Example: Netlify
netlify deploy --prod --dir=dist
```

#### Option 2: Docker (Nginx)

```bash
# Build Docker image
cd scanner/
docker build -t qr-scanner:3.0.0 .

# Run container
docker run -d \
    -p 443:443 \
    -v /certs:/etc/nginx/certs \
    qr-scanner:3.0.0

# Access at https://localhost
```

#### Option 3: Self-Hosted

```bash
# Build
cd scanner/
npm run build

# Serve with any web server
# Nginx:
server {
    listen 443 ssl http2;
    server_name qr-scanner.example.com;

    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;

    root /var/www/qr-scanner;
    index index.html;

    location / {
        try_files $uri $uri/ /index.html;
    }

    # Service worker
    location /sw.js {
        add_header Cache-Control "no-cache";
    }
}
```

---

## üìà Monitoring & Observability

### Metrics to Track

#### Generator Metrics

```python
# Prometheus metrics
from prometheus_client import Counter, Histogram

qr_generation_total = Counter(
    'qr_generation_total',
    'Total QR codes generated'
)

qr_generation_duration = Histogram(
    'qr_generation_duration_seconds',
    'Time spent generating QR codes'
)

file_size_bytes = Histogram(
    'file_size_bytes',
    'Size of files being processed'
)
```

#### Scanner Metrics

```javascript
// Custom metrics
const metrics = {
    scansTotal: 0,
    scanSuccesses: 0,
    scanErrors: 0,
    averageScanTime: 0,
    chunksReceived: 0,
    transfersCompleted: 0
};

// Send to analytics endpoint
if (config.metrics.enabled) {
    fetch('/api/metrics', {
        method: 'POST',
        body: JSON.stringify(metrics)
    });
}
```

### Logging

```yaml
# logging.yaml
version: 1
formatters:
  json:
    format: '{"timestamp": "%(asctime)s", "level": "%(levelname)s", "message": "%(message)s"}'

handlers:
  console:
    class: logging.StreamHandler
    formatter: json

  file:
    class: logging.RotatingFileHandler
    filename: /var/log/qr-generator/app.log
    maxBytes: 10485760  # 10MB
    backupCount: 5
    formatter: json

root:
  level: INFO
  handlers: [console, file]
```

---

## üß™ Testing Strategy

### Testing Pyramid

```
                /\
               /  \
              /E2E \
             /Tests \
            /‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\
           /          \
          / Integration\
         /    Tests     \
        /‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\
       /                  \
      /   Unit Tests       \
     /______________________\
```

### Test Coverage Targets

| Component          | Unit | Integration | E2E | Total |
|--------------------|------|-------------|-----|-------|
| Generator Core     | 90%  | 80%         | -   | 85%   |
| Generator API      | 80%  | 90%         | 70% | 80%   |
| Scanner Core       | 85%  | 75%         | -   | 80%   |
| Scanner UI         | 70%  | 80%         | 90% | 80%   |
| **Overall**        | 80%+ | 80%+        | 70%+| 80%+  |

### Running All Tests

```bash
# Generator
cd generator/
pytest --cov=src --cov-report=html

# Scanner
cd scanner/
npm test -- --coverage
npm run test:e2e

# View coverage
# generator/htmlcov/index.html
# scanner/coverage/index.html
```

---

## üìö Documentation Standards

### Required Documentation

#### Generator
- [x] ARCHITECTURE.md - System design
- [x] IMPLEMENTATION.md - Code guide
- [x] README.md - Getting started
- [ ] API.md - API reference
- [ ] SECURITY.md - Security guide
- [ ] DEPLOYMENT.md - Deployment guide

#### Scanner
- [x] ARCHITECTURE.md - System design
- [x] IMPLEMENTATION.md - Code guide
- [x] README.md - Getting started
- [ ] USER_GUIDE.md - End-user guide
- [ ] TROUBLESHOOTING.md - Common issues
- [ ] DEPLOYMENT.md - Deployment guide

### Documentation Template

```markdown
# [Feature Name]

## Overview
Brief description of feature

## Architecture
How it fits in the system

## Implementation
Code examples and details

## Configuration
Settings and options

## Testing
How to test this feature

## Deployment
Deployment considerations

## Troubleshooting
Common issues and solutions

## References
Links to related documentation
```

---

## üéì Training & Onboarding

### Developer Onboarding Checklist

#### Week 1: Setup & Basics
- [ ] Development environment setup
- [ ] Read ARCHITECTURE.md (both apps)
- [ ] Run generator locally
- [ ] Run scanner locally
- [ ] Complete first end-to-end transfer

#### Week 2: Deep Dive
- [ ] Read IMPLEMENTATION.md (both apps)
- [ ] Write first unit test
- [ ] Fix a "good first issue"
- [ ] Code review participation

#### Week 3: Advanced
- [ ] Implement a small feature
- [ ] Write integration test
- [ ] Deploy to test environment
- [ ] Present work to team

### User Training Materials

- [ ] User guide (PDF)
- [ ] Video tutorials
- [ ] Quick reference cards
- [ ] FAQ document
- [ ] Troubleshooting guide

---

## üÜò Support & Maintenance

### Support Tiers

**Tier 1: Self-Service**
- Documentation
- FAQ
- Knowledge base
- Community forums

**Tier 2: Standard Support**
- Email support
- Response time: 24-48 hours
- Business hours only
- Bug fixes in next release

**Tier 3: Premium Support**
- Priority email + phone
- Response time: 4 hours
- 24/7 availability
- Hotfix releases
- Custom development

### Maintenance Schedule

```
Daily:
- Monitor error logs
- Check system health
- Respond to critical issues

Weekly:
- Review metrics
- Update documentation
- Triage new issues
- Plan next sprint

Monthly:
- Security updates
- Dependency updates
- Performance review
- Release planning

Quarterly:
- Security audit
- Architecture review
- Capacity planning
- User feedback session
```

---

## üó∫Ô∏è Roadmap

### Version 3.1 (Q2 2025)
- Video streaming mode
- Multi-device sync
- Advanced error recovery
- Mobile apps (iOS/Android)

### Version 4.0 (Q4 2025)
- Quantum-resistant encryption
- WebRTC peer-to-peer
- Blockchain verification
- AI-powered optimization

### Version 5.0 (2026)
- Satellite communication mode
- Mesh network support
- Hardware security module integration
- Advanced analytics platform

---

## üìù License & Legal

### License
MIT License - see LICENSE file for details

### Compliance
- GDPR compliant (no data collection)
- HIPAA ready (air-gapped design)
- SOC 2 compatible
- ISO 27001 aligned

### Intellectual Property
- All code is open source
- QR code technology is patent-free
- Encryption algorithms are public domain

---

## üë• Team Structure

### Recommended Team

**Development Team:**
- 1x Technical Lead
- 2x Backend Developers (Generator)
- 2x Frontend Developers (Scanner)
- 1x DevOps Engineer
- 1x QA Engineer

**Support Team:**
- 1x Product Manager
- 1x Technical Writer
- 1x Support Engineer

**Part-Time:**
- 1x Security Consultant
- 1x UX Designer

---

## üìû Contact & Resources

### Project Resources
- **Repository**: https://github.com/your-org/qr-transfer
- **Documentation**: https://docs.qr-transfer.com
- **Issues**: https://github.com/your-org/qr-transfer/issues
- **Discussions**: https://github.com/your-org/qr-transfer/discussions

### Communication Channels
- **Slack**: #qr-transfer-dev
- **Email**: dev@qr-transfer.com
- **Status Page**: https://status.qr-transfer.com

---

**Document Version**: 1.0.0
**Last Updated**: 2025-11-13
**Status**: Ready for Implementation
**Next Review**: 2025-12-13

---

## üîí AIR-GAP DEPLOYMENT (MILITARY-GRADE)

### Critical Requirements for Air-Gap Compliance

**‚ö†Ô∏è IMPORTANT**: True air-gap deployment means **ZERO network connectivity**. The following features must be REMOVED or deployed offline-only:

#### Generator Requirements
- ‚ùå **NO REST API** - Remove FastAPI/web server code entirely
- ‚ùå **NO WebSocket** - Remove all network communication
- ‚ùå **NO Docker Hub** - Use offline Docker images only or skip Docker
- ‚ùå **NO Cloud Monitoring** - Use local file logging only
- ‚úÖ **CLI/GUI Only** - Standalone executable deployment
- ‚úÖ **USB Deployment** - Physical media transfer only

#### Scanner Requirements  
- ‚ùå **NO CDN Libraries** - Bundle ALL JavaScript libraries locally
- ‚ùå **NO Web Hosting** - Deploy to local file system only
- ‚ùå **NO Service Worker Network Fallback** - Offline-only mode
- ‚úÖ **Single HTML File** - All dependencies inlined (~500KB)
- ‚úÖ **USB/CD Deployment** - Physical media distribution

### Air-Gap Deployment Process

```
DEVELOPMENT MACHINE (Connected)
    ‚Üì
[Build & Package]
    ‚Üì
[Hash Verification]
    ‚Üì
[Copy to USB/CD with Write-Protection]
    ‚Üì
[Apply Tamper-Evident Seal]
    ‚Üì
[Physical Transport - Secure Courier]
    ‚Üì
AIR-GAPPED ENVIRONMENT (Isolated)
    ‚Üì
[Verify Seal & Hash]
    ‚Üì
[Install Locally]
    ‚Üì
[Test - Verify NO Network Activity]
    ‚Üì
[Destroy/Secure Media]
```

### Generator: Build for Air-Gap

```bash
# 1. Build single executable (NO network code)
cd generator/
pyinstaller --onefile --name QRGenerator src/main.py

# 2. Verify no network symbols
nm dist/QRGenerator | grep -E "socket|connect|http" || echo "‚úÖ Clean"

# 3. Calculate hash
sha256sum dist/QRGenerator > deployment_hash.txt

# 4. Copy to USB (write-protected)
cp dist/QRGenerator /mnt/usb/
cp deployment_hash.txt /mnt/usb/

# 5. Verify and seal USB
```

### Scanner: Build for Air-Gap

```bash
# 1. Bundle ALL dependencies locally
cd scanner/public/

# Download qr-scanner library locally
mkdir -p lib/
curl -o lib/qr-scanner.umd.min.js \
  https://cdn.jsdelivr.net/npm/qr-scanner@1.4.2/qr-scanner.umd.min.js

# 2. Update index.html to use local library
sed -i 's|https://cdn.jsdelivr.net.*qr-scanner.*|./lib/qr-scanner.umd.min.js|g' index.html

# 3. Create single-file version (all inlined)
cat > scanner_airgap.html << 'HTML'
<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>QR Scanner</title>
<style>/* All CSS inlined here */</style>
</head>
<body>
<!-- All HTML here -->
<script>/* All JS including qr-scanner library inlined */</script>
</body>
</html>
HTML

# 4. Calculate hash
sha256sum scanner_airgap.html > scanner_hash.txt

# 5. Burn to CD-R (recommended) or copy to USB
```

### Verification Checklist

**Before Deployment:**
- [ ] Generator: No network imports in code
- [ ] Generator: No URLs in binary (check with `strings`)
- [ ] Generator: Single executable with no dependencies
- [ ] Scanner: No `http://` or `https://` in HTML
- [ ] Scanner: All libraries present in `lib/` folder
- [ ] Scanner: Works offline (test with network disabled)
- [ ] Both: Hashes calculated and documented
- [ ] Both: Physical media write-protected

**After Deployment:**
- [ ] Hashes verified on air-gap machine
- [ ] No network activity detected (use `tcpdump` or `wireshark`)
- [ ] Applications function correctly offline
- [ ] Test file transfer successful
- [ ] Audit trail documented

### Deployment to Classified Environment

```bash
# On air-gap machine (after transport):

# 1. Verify hash
sha256sum QRGenerator  # Compare with deployment_hash.txt
sha256sum scanner_airgap.html  # Compare with scanner_hash.txt

# 2. Install generator
sudo cp QRGenerator /opt/qr/
sudo chmod +x /opt/qr/QRGenerator

# 3. Install scanner
cp scanner_airgap.html ~/Desktop/qr_scanner.html

# 4. Test with network monitoring
sudo tcpdump -i any &  # Monitor ALL network activity
/opt/qr/QRGenerator generate test.txt
# Open scanner_airgap.html in browser
# Scan QR codes
# Verify: tcpdump shows ZERO network packets
kill %1

# 5. If test passes, approve for use
```

### Security Compliance

**Classification Levels Supported:**
- UNCLASSIFIED (code itself)
- SECRET (operational deployment)
- TOP SECRET (with additional controls)

**Required Controls:**
- Physical security of deployment media
- Chain of custody documentation
- Hash verification at source and destination
- Network activity monitoring during testing
- Incident response procedures
- Periodic security audits

### Incident Response

**If Network Activity Detected:**
1. IMMEDIATELY power off system
2. Preserve all logs
3. Notify security officer
4. Document incident
5. Await security investigation
6. Do NOT restart until cleared

**If Hash Mismatch:**
1. Do NOT install/use
2. Quarantine media
3. Notify security officer
4. Request new deployment
5. Document in audit trail

